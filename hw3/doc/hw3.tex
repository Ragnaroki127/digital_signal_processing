\documentclass[12pt]{ctexart}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage[shortlabels]{enumitem}
\usepackage{authblk}
\usepackage{graphicx}
\usepackage{float}
\usepackage{titlesec}

\title{数字信号处理第三次作业}
\author{闫昊昕}
\date{\today}
\affil{2019210361}

\titleformat{\section}{\raggedright\large\bfseries}{第\,\thesection\,题}{1em}{}

\begin{document}
    \maketitle

    \pagestyle{empty}
    \section{}
    个人编写的n点FFT程序在fft.py中定义。该函数接受两个参数为函数输入：信号点序列$x_n$以及信号点数$N$。该函数要求信号点数严格为2的整数次幂。\par
    对一个输入16384点信号$f(n)=sin(2\pi\times 50n) + cos(2\pi\times 100n)$，个人编写的fft程序以及numpy包自带的fft程序得到的频谱图像如下：
    \begin{figure}[H]
        \centering
        \includegraphics[width=0.6\textwidth]{Figure_1.png}
        \caption{个人编写的基2FFT程序结果}
    \end{figure}
    \begin{figure}[H]
        \centering
        \includegraphics[width=0.6\textwidth]{Figure_2.png}
        \caption{Numpy自带的FFT程序结果}
    \end{figure} \par
    运行时间方面，个人编写的FFT程序可以在0.2秒左右的时间内完成对16384点信号的FFT运算，在运行速度上远远高于DFT算法，但和np.fft.fft函数相比运行速度仍然明显较慢，如下图所示：
    \begin{figure}[H]
        \centering
        \includegraphics[width=0.6\textwidth]{Figure_3.png}
        \caption{两种程序的运行时间比较}
    \end{figure}
    同时可以看到随着N的增加程序运行速度的变化约为线性，这与FFT算法的时间复杂度$O(n\log n)$相吻合。

    \section{}
    可以用两种方式实现函数的自相关，一种是根据定义实现序列的自相关，另一种方式是先对序列进行FFT得到其频谱，再做平方运算得到功率谱，最后做IFFT得到自相关函数的估计，本题中自相关函数的主要实现方式为定义法，功率谱法做验证使用。
    \begin{figure}[H]
        \centering
        \includegraphics[width=0.6\textwidth]{Figure_4.png}
        \caption{原信号的时域表示}\label{fig:original}
    \end{figure}
    \begin{figure}[H]
        \centering
        \includegraphics[width=0.6\textwidth]{Figure_5.png}
        \caption{根据定义实现的自相关函数}\label{fig:self}
    \end{figure}
    \begin{figure}[H]
        \centering
        \includegraphics[width=0.6\textwidth]{Figure_6.png}
        \caption{根据功率谱原理得到的自相关函数}\label{fig:val}
    \end{figure} \par
    图\ref{fig:original}为原信号的时域表示，图\ref{fig:self}为通过根据定义计算的自相关函数得到的自相关函数谱，图\ref{fig:val}为通过功率谱方法估计的自相关函数。可以看到原信号的自相关函数关于频谱中心对称，与理论相符合。
\end{document}